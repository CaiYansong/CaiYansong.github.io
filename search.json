[{"title":"深浅拷贝","url":"/2020/09/06/clone/","content":"# javaScript的变量类型（1）基本类型：5种基本数据类型undefined、null、Boolean、Number、String、Symbol，变量是直接存放值的，存放在栈内存中的简单数据段，可以直接访问。（2）引用类型：存放在堆内存中的对象，在栈内存中变量保存的是一个指针，这个指针指向堆内存中对应数据的地址。当需要访问引用类型（如对象，数组等）的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据。JavaScript存储对象都是存地址的引用类型，所以浅拷贝会导致 obj1 和obj2 指向同一块内存地址。改变了其中一方的内容，都是在原来的内存上做修改会导致拷贝对象和源对象都发生改变。而深拷贝是开辟一块新的内存地址，将原对象的各个属性逐个复制进去。对拷贝对象和源对象各自的操作互不影响。# 赋值、浅拷贝、深拷贝深拷贝：将 B 对象拷贝到 A 对象中，包括 B 里面的子对象，浅拷贝：将 B 对象拷贝到 A 对象中，但不包括 B 里面的子对象|  | 和原数据是否指向同一对象 | 第一层数据为基本数据类型 | 原数据中包含子对象 || --- | --- | --- | --- || 赋值 | 是 | 改变会使原数据一同改变 | 改变会使原数据一同改变 || 浅拷贝 | 否 | 改变不会使原数据一同改变 | 改变会使原数据一同改变 || 深拷贝 | 否 | 改变不会使原数据一同改变 | 改变不会使原数据一同改变 |# 赋值# 浅拷贝拷贝原对象的实例，但是对其内部的引用类型值，拷贝的是其引用，常用的就是如- jquey中的$.extend({}, obj); - Array.prototype.slice()- Array.prototype.concat()- Object.assign()- 扩展运算符{ ...obj }、[ ...arr ]都会返回一个数组或者对象的浅拷贝`Object.assign()` 只对顶层属性做了赋值，完全没有继续做递归之类的把所有下一层的属性做深拷贝。只是一级属性复制。 slice()concat# 深拷贝测试用例## JSON.stringify() 和 JSON.parse() 1.无法实现对 函数、RegExp、Date等 特殊对象的克隆2.会抛弃对象的constructor,所有的构造函数会指向Object3.对象有循环引用,会报错可以看出通过JSON.stringify先将对象转化为字符换，然后再通过JSON.parse()转化为对象，这个对象就是完全在开辟的新的内存空间中的对象 。## 递归简版## 循环## 测试"},{"title":"test img","url":"/2020/09/05/test-img/","content":"test imghttps://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3770410044,1864591641&fm=26&gp=0.jpg![Alt text]"},{"title":"null page","url":"/2020/09/04/null-page/","content":"null page"},{"title":"test copy","url":"/2020/09/04/test copy/","content":"test copy"},{"title":"test","url":"/2020/09/04/test/","content":"test"},{"title":"Hello World","url":"/2020/04/11/hello-world/","content":"Welcome to [Hexo]! This is your very first post. Check [documentation] for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting] or you can ask me on [GitHub].## Quick Start### Create a new postMore info: [Writing]### Run serverMore info: [Server]### Generate static filesMore info: [Generating]### Deploy to remote sitesMore info: [Deployment]"}]