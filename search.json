[{"title":"闭包","url":"/2020/09/08/bi-bao/","content":"# 概念> MDN:> A **closure** is the combination of a function bundled together (enclosed) with references to its surrounding state (the **lexical environment**). In other words, a closure gives you access to an outer function’s scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time.函数和对其周围状态（**lexical environment，词法环境**）的引用捆绑在一起构成**闭包**。也就是说，闭包可以让你从内部函数访问外部函数作用域。在 JavaScript 中，每当函数被创建，就会在函数生成时生成闭包。闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量，利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。# 特性1.函数嵌套函数，父级函数 返回 子函数体 给全局。2.子函数 访问 父级函数 的局部变量3.变量不会被垃圾回收机制回收目的：把局部变量 变成 自由变量（生命周期永久的和页面同存）作用：函数内部的变量可以在外部被访问⚠️ 函数嵌套函数+内部函数使用了外部函数的自由变量⚠️ 函数嵌套了异步函数，该异步函数不算是内层函数。类似于setTimeout等异步函数中的回调函数，不算内层函数# 缺点常驻内存，会增大内存的使用量，使用不当会造成内存泄漏。闭包产生的变量不用了就赋值为null，垃圾回收机制就会释放掉。# 示例函数fatherFn 的子函数childFn，被函数fatherFn 外部的一个变量outerFn引用的时候，就创建了一个闭包。在执行完 var outerFn = fatherFn() 后，变量outerFn实际上是指向了函数childFn，再执行outerFn() 后就会打印val的值(第一次为11)。这段代码其实就创建了一个闭包。因为 函数fatherFn 外的 变量outerFn 引用了 函数fatherFn 内的 函数childFn。```javascript// 正确的写法function father(){  var array = [];  for (var i=0; i"},{"title":"深浅拷贝","url":"/2020/09/06/clone/","content":"# javaScript的变量类型（1）基本类型：5种基本数据类型undefined、null、Boolean、Number、String、Symbol，变量是直接存放值的，存放在栈内存中的简单数据段，可以直接访问。（2）引用类型：存放在堆内存中的对象，在栈内存中变量保存的是一个指针，这个指针指向堆内存中对应数据的地址。当需要访问引用类型（如对象，数组等）的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据。JavaScript存储对象都是存地址的引用类型，所以浅拷贝会导致 obj1 和obj2 指向同一块内存地址。改变了其中一方的内容，都是在原来的内存上做修改会导致拷贝对象和源对象都发生改变。而深拷贝是开辟一块新的内存地址，将原对象的各个属性逐个复制进去。对拷贝对象和源对象各自的操作互不影响。# 赋值、浅拷贝、深拷贝深拷贝：将 B 对象拷贝到 A 对象中，包括 B 里面的子对象，浅拷贝：将 B 对象拷贝到 A 对象中，但不包括 B 里面的子对象|  | 和原数据是否指向同一对象 | 第一层数据为基本数据类型 | 原数据中包含子对象 || --- | --- | --- | --- || 赋值 | 是 | 改变会使原数据一同改变 | 改变会使原数据一同改变 || 浅拷贝 | 否 | 改变不会使原数据一同改变 | 改变会使原数据一同改变 || 深拷贝 | 否 | 改变不会使原数据一同改变 | 改变不会使原数据一同改变 |# 赋值# 浅拷贝拷贝原对象的实例，但是对其内部的引用类型值，拷贝的是其引用，常用的就是如- jquey中的$.extend({}, obj); - Array.prototype.slice()- Array.prototype.concat()- Object.assign()- 扩展运算符{ ...obj }、[ ...arr ]都会返回一个数组或者对象的浅拷贝`Object.assign()` 只对顶层属性做了赋值，完全没有继续做递归之类的把所有下一层的属性做深拷贝。只是一级属性复制。 slice()concat# 深拷贝测试用例## JSON.stringify() 和 JSON.parse() 1.无法实现对 函数、RegExp、Date等 特殊对象的克隆2.会抛弃对象的constructor,所有的构造函数会指向Object3.对象有循环引用,会报错可以看出通过JSON.stringify先将对象转化为字符换，然后再通过JSON.parse()转化为对象，这个对象就是完全在开辟的新的内存空间中的对象 。## 递归简版## 循环## 测试"},{"title":"test img","url":"/2020/09/05/test-img/","content":"test imghttps://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3770410044,1864591641&fm=26&gp=0.jpg![Alt text]"},{"title":"null page","url":"/2020/09/04/null-page/","content":"null page"},{"title":"测试","url":"/2020/09/04/ce-shi/","content":"中文文件名测试"},{"title":"test","url":"/2020/09/04/test/","content":"test"},{"title":"Hello World","url":"/2020/04/11/hello-world/","content":"Welcome to [Hexo]! This is your very first post. Check [documentation] for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting] or you can ask me on [GitHub].## Quick Start### Create a new postMore info: [Writing]### Run serverMore info: [Server]### Generate static filesMore info: [Generating]### Deploy to remote sitesMore info: [Deployment]"}]